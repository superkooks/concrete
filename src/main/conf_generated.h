// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONF_H_
#define FLATBUFFERS_GENERATED_CONF_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

struct ConcreteConfig;
struct ConcreteConfigBuilder;

struct PartitionConfig;
struct PartitionConfigBuilder;

struct VirtSensorConfig;
struct VirtSensorConfigBuilder;

struct KeypadConfig;
struct KeypadConfigBuilder;

struct PhysSensorConfig;
struct PhysSensorConfigBuilder;

struct OutputConfig;
struct OutputConfigBuilder;

struct ConcreteConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConcreteConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTITIONS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PartitionConfig>> *partitions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PartitionConfig>> *>(VT_PARTITIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARTITIONS) &&
           verifier.VerifyVector(partitions()) &&
           verifier.VerifyVectorOfTables(partitions()) &&
           verifier.EndTable();
  }
};

struct ConcreteConfigBuilder {
  typedef ConcreteConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_partitions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PartitionConfig>>> partitions) {
    fbb_.AddOffset(ConcreteConfig::VT_PARTITIONS, partitions);
  }
  explicit ConcreteConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConcreteConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConcreteConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConcreteConfig> CreateConcreteConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PartitionConfig>>> partitions = 0) {
  ConcreteConfigBuilder builder_(_fbb);
  builder_.add_partitions(partitions);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConcreteConfig> CreateConcreteConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PartitionConfig>> *partitions = nullptr) {
  auto partitions__ = partitions ? _fbb.CreateVector<::flatbuffers::Offset<PartitionConfig>>(*partitions) : 0;
  return CreateConcreteConfig(
      _fbb,
      partitions__);
}

struct PartitionConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartitionConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VIRT_SENSORS = 6,
    VT_KEYPADS = 8,
    VT_OUTPUTS = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<VirtSensorConfig>> *virt_sensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<VirtSensorConfig>> *>(VT_VIRT_SENSORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<KeypadConfig>> *keypads() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<KeypadConfig>> *>(VT_KEYPADS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<OutputConfig>> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<OutputConfig>> *>(VT_OUTPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VIRT_SENSORS) &&
           verifier.VerifyVector(virt_sensors()) &&
           verifier.VerifyVectorOfTables(virt_sensors()) &&
           VerifyOffset(verifier, VT_KEYPADS) &&
           verifier.VerifyVector(keypads()) &&
           verifier.VerifyVectorOfTables(keypads()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           verifier.EndTable();
  }
};

struct PartitionConfigBuilder {
  typedef PartitionConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PartitionConfig::VT_NAME, name);
  }
  void add_virt_sensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VirtSensorConfig>>> virt_sensors) {
    fbb_.AddOffset(PartitionConfig::VT_VIRT_SENSORS, virt_sensors);
  }
  void add_keypads(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KeypadConfig>>> keypads) {
    fbb_.AddOffset(PartitionConfig::VT_KEYPADS, keypads);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OutputConfig>>> outputs) {
    fbb_.AddOffset(PartitionConfig::VT_OUTPUTS, outputs);
  }
  explicit PartitionConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartitionConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartitionConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartitionConfig> CreatePartitionConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<VirtSensorConfig>>> virt_sensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<KeypadConfig>>> keypads = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<OutputConfig>>> outputs = 0) {
  PartitionConfigBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_keypads(keypads);
  builder_.add_virt_sensors(virt_sensors);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PartitionConfig> CreatePartitionConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<VirtSensorConfig>> *virt_sensors = nullptr,
    const std::vector<::flatbuffers::Offset<KeypadConfig>> *keypads = nullptr,
    const std::vector<::flatbuffers::Offset<OutputConfig>> *outputs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto virt_sensors__ = virt_sensors ? _fbb.CreateVector<::flatbuffers::Offset<VirtSensorConfig>>(*virt_sensors) : 0;
  auto keypads__ = keypads ? _fbb.CreateVector<::flatbuffers::Offset<KeypadConfig>>(*keypads) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<::flatbuffers::Offset<OutputConfig>>(*outputs) : 0;
  return CreatePartitionConfig(
      _fbb,
      name__,
      virt_sensors__,
      keypads__,
      outputs__);
}

struct VirtSensorConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VirtSensorConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SENSOR_ADDR = 4,
    VT_ENTRY_DELAY = 6,
    VT_EXIT_DELAY = 8,
    VT_CHIME_ARMED = 10,
    VT_CHIME_DISARMED = 12,
    VT_TAMPER_ARMED = 14,
    VT_TAMPER_DISARMED = 16
  };
  uint32_t sensor_addr() const {
    return GetField<uint32_t>(VT_SENSOR_ADDR, 0);
  }
  int32_t entry_delay() const {
    return GetField<int32_t>(VT_ENTRY_DELAY, 0);
  }
  int32_t exit_delay() const {
    return GetField<int32_t>(VT_EXIT_DELAY, 0);
  }
  bool chime_armed() const {
    return GetField<uint8_t>(VT_CHIME_ARMED, 0) != 0;
  }
  bool chime_disarmed() const {
    return GetField<uint8_t>(VT_CHIME_DISARMED, 0) != 0;
  }
  bool tamper_armed() const {
    return GetField<uint8_t>(VT_TAMPER_ARMED, 0) != 0;
  }
  bool tamper_disarmed() const {
    return GetField<uint8_t>(VT_TAMPER_DISARMED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SENSOR_ADDR, 4) &&
           VerifyField<int32_t>(verifier, VT_ENTRY_DELAY, 4) &&
           VerifyField<int32_t>(verifier, VT_EXIT_DELAY, 4) &&
           VerifyField<uint8_t>(verifier, VT_CHIME_ARMED, 1) &&
           VerifyField<uint8_t>(verifier, VT_CHIME_DISARMED, 1) &&
           VerifyField<uint8_t>(verifier, VT_TAMPER_ARMED, 1) &&
           VerifyField<uint8_t>(verifier, VT_TAMPER_DISARMED, 1) &&
           verifier.EndTable();
  }
};

struct VirtSensorConfigBuilder {
  typedef VirtSensorConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_sensor_addr(uint32_t sensor_addr) {
    fbb_.AddElement<uint32_t>(VirtSensorConfig::VT_SENSOR_ADDR, sensor_addr, 0);
  }
  void add_entry_delay(int32_t entry_delay) {
    fbb_.AddElement<int32_t>(VirtSensorConfig::VT_ENTRY_DELAY, entry_delay, 0);
  }
  void add_exit_delay(int32_t exit_delay) {
    fbb_.AddElement<int32_t>(VirtSensorConfig::VT_EXIT_DELAY, exit_delay, 0);
  }
  void add_chime_armed(bool chime_armed) {
    fbb_.AddElement<uint8_t>(VirtSensorConfig::VT_CHIME_ARMED, static_cast<uint8_t>(chime_armed), 0);
  }
  void add_chime_disarmed(bool chime_disarmed) {
    fbb_.AddElement<uint8_t>(VirtSensorConfig::VT_CHIME_DISARMED, static_cast<uint8_t>(chime_disarmed), 0);
  }
  void add_tamper_armed(bool tamper_armed) {
    fbb_.AddElement<uint8_t>(VirtSensorConfig::VT_TAMPER_ARMED, static_cast<uint8_t>(tamper_armed), 0);
  }
  void add_tamper_disarmed(bool tamper_disarmed) {
    fbb_.AddElement<uint8_t>(VirtSensorConfig::VT_TAMPER_DISARMED, static_cast<uint8_t>(tamper_disarmed), 0);
  }
  explicit VirtSensorConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VirtSensorConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VirtSensorConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VirtSensorConfig> CreateVirtSensorConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sensor_addr = 0,
    int32_t entry_delay = 0,
    int32_t exit_delay = 0,
    bool chime_armed = false,
    bool chime_disarmed = false,
    bool tamper_armed = false,
    bool tamper_disarmed = false) {
  VirtSensorConfigBuilder builder_(_fbb);
  builder_.add_exit_delay(exit_delay);
  builder_.add_entry_delay(entry_delay);
  builder_.add_sensor_addr(sensor_addr);
  builder_.add_tamper_disarmed(tamper_disarmed);
  builder_.add_tamper_armed(tamper_armed);
  builder_.add_chime_disarmed(chime_disarmed);
  builder_.add_chime_armed(chime_armed);
  return builder_.Finish();
}

struct KeypadConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeypadConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOARD_ADDR = 4,
    VT_SHOW_ARMED = 6
  };
  uint32_t board_addr() const {
    return GetField<uint32_t>(VT_BOARD_ADDR, 0);
  }
  bool show_armed() const {
    return GetField<uint8_t>(VT_SHOW_ARMED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_BOARD_ADDR, 4) &&
           VerifyField<uint8_t>(verifier, VT_SHOW_ARMED, 1) &&
           verifier.EndTable();
  }
};

struct KeypadConfigBuilder {
  typedef KeypadConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_board_addr(uint32_t board_addr) {
    fbb_.AddElement<uint32_t>(KeypadConfig::VT_BOARD_ADDR, board_addr, 0);
  }
  void add_show_armed(bool show_armed) {
    fbb_.AddElement<uint8_t>(KeypadConfig::VT_SHOW_ARMED, static_cast<uint8_t>(show_armed), 0);
  }
  explicit KeypadConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeypadConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeypadConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeypadConfig> CreateKeypadConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t board_addr = 0,
    bool show_armed = false) {
  KeypadConfigBuilder builder_(_fbb);
  builder_.add_board_addr(board_addr);
  builder_.add_show_armed(show_armed);
  return builder_.Finish();
}

struct PhysSensorConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PhysSensorConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDR = 4,
    VT_NAME = 6
  };
  uint32_t addr() const {
    return GetField<uint32_t>(VT_ADDR, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ADDR, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct PhysSensorConfigBuilder {
  typedef PhysSensorConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_addr(uint32_t addr) {
    fbb_.AddElement<uint32_t>(PhysSensorConfig::VT_ADDR, addr, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PhysSensorConfig::VT_NAME, name);
  }
  explicit PhysSensorConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PhysSensorConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PhysSensorConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PhysSensorConfig> CreatePhysSensorConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t addr = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  PhysSensorConfigBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_addr(addr);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PhysSensorConfig> CreatePhysSensorConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t addr = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreatePhysSensorConfig(
      _fbb,
      addr,
      name__);
}

struct OutputConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OutputConfigBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDR = 4,
    VT_NAME = 6
  };
  uint32_t addr() const {
    return GetField<uint32_t>(VT_ADDR, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ADDR, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct OutputConfigBuilder {
  typedef OutputConfig Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_addr(uint32_t addr) {
    fbb_.AddElement<uint32_t>(OutputConfig::VT_ADDR, addr, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(OutputConfig::VT_NAME, name);
  }
  explicit OutputConfigBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OutputConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OutputConfig>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OutputConfig> CreateOutputConfig(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t addr = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  OutputConfigBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_addr(addr);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OutputConfig> CreateOutputConfigDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t addr = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateOutputConfig(
      _fbb,
      addr,
      name__);
}

#endif  // FLATBUFFERS_GENERATED_CONF_H_
